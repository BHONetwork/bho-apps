"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[425],{53425:(e,t,s)=>{s.r(t),s.d(t,{SmoldotProvider:()=>K});var i={};s.r(i),s.d(i,{AddChainError:()=>y,AlreadyDestroyedError:()=>v,CrashError:()=>E,JsonRpcDisabledError:()=>C,healthChecker:()=>k,start:()=>W});var a,n,r,o,h,c,l,d,f=s(42537),u=s(4615),p=s(48731),w=s(10161),b=function(e,t,s,i,a){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!a)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!a:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?a.call(e,s):a?a.value=s:t.set(e,s),s},m=function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)};function k(){let e=null,t=null;return{setSendJsonRpc:e=>{t=e},start:s=>{if(null!==e)throw new Error("Can't start the health checker multiple times in parallel");if(!t)throw new Error("setSendJsonRpc must be called before starting the health checks");e=new g(s,t),e.startHealthCheck()},stop:()=>{null!==e&&(e.destroy(),e=null)},sendJsonRpc:s=>{if(!t)throw new Error("setSendJsonRpc must be called before sending requests");null===e?t(s):e.sendJsonRpc(s)},responsePassThrough:t=>null===e?t:e.responsePassThrough(t)}}class g{constructor(e,t){a.set(this,void 0),n.set(this,null),r.set(this,null),o.set(this,null),h.set(this,null),c.set(this,void 0),l.set(this,!1),d.set(this,0),b(this,a,e,"f"),b(this,c,t,"f")}sendJsonRpc(e){let t;try{t=JSON.parse(e)}catch(e){return}if(t.id){const e="extern:"+JSON.stringify(t.id);t.id=e}m(this,c,"f").call(this,JSON.stringify(t))}responsePassThrough(e){let t;try{t=JSON.parse(e)}catch(t){return e}if(t.id&&m(this,n,"f")==t.id)return b(this,n,null,"f"),t.result?(m(this,a,"f").call(this,t.result),b(this,l,t.result.isSyncing,"f"),this.update(),null):(this.update(),null);if(t.id&&m(this,o,"f")==t.id)return b(this,o,null,"f"),t.result?(m(this,h,"f")?b(this,h,null,"f"):b(this,h,t.result,"f"),this.update(),null):(this.update(),null);if(t.params&&m(this,h,"f")&&t.params.subscription==m(this,h,"f"))return this.startHealthCheck(),this.update(),null;if(t.id){if(!t.id.startsWith("extern:"))throw new Error("State inconsistency in health checker");const e=JSON.parse(t.id.slice("extern:".length));t.id=e}return JSON.stringify(t)}update(){m(this,r,"f")||b(this,r,setTimeout((()=>{b(this,r,null,"f"),this.startHealthCheck()}),1e4),"f"),!m(this,l,"f")||m(this,h,"f")||m(this,o,"f")||this.startSubscription(),m(this,l,"f")||!m(this,h,"f")||m(this,o,"f")||this.endSubscription()}startHealthCheck(){if(m(this,n,"f"))throw new Error("Internal error in health checker");m(this,r,"f")&&(clearTimeout(m(this,r,"f")),b(this,r,null,"f")),b(this,n,"health-checker:"+m(this,d,"f"),"f"),b(this,d,m(this,d,"f")+1,"f"),m(this,c,"f").call(this,JSON.stringify({jsonrpc:"2.0",id:m(this,n,"f"),method:"system_health",params:[]}))}startSubscription(){if(m(this,o,"f")||m(this,h,"f"))throw new Error("Internal error in health checker");b(this,o,"health-checker:"+m(this,d,"f"),"f"),b(this,d,m(this,d,"f")+1,"f"),m(this,c,"f").call(this,JSON.stringify({jsonrpc:"2.0",id:m(this,o,"f"),method:"chain_subscribeNewHeads",params:[]}))}endSubscription(){if(m(this,o,"f")||!m(this,h,"f"))throw new Error("Internal error in health checker");b(this,o,"health-checker:"+m(this,d,"f"),"f"),b(this,d,m(this,d,"f")+1,"f"),m(this,c,"f").call(this,JSON.stringify({jsonrpc:"2.0",id:m(this,o,"f"),method:"chain_unsubscribeNewHeads",params:[m(this,h,"f")]}))}destroy(){m(this,r,"f")&&(clearTimeout(m(this,r,"f")),b(this,r,null,"f"))}}a=new WeakMap,n=new WeakMap,r=new WeakMap,o=new WeakMap,h=new WeakMap,c=new WeakMap,l=new WeakMap,d=new WeakMap;class y extends Error{constructor(e){super(e)}}class v extends Error{}class C extends Error{}class E extends Error{constructor(e){super(e)}}function W(e){const t=(e=e||{}).logCallback||((e,t,s)=>{e<=1?console.error("[%s] %s",t,s):2==e?console.warn("[%s] %s",t,s):3==e?console.info("[%s] %s",t,s):4==e?console.debug("[%s] %s",t,s):console.trace("[%s] %s",t,s)}),i=function(){if(!window.Worker)throw new Error("Workers not available");return new Worker(new URL(s.p+s.u(726),s.b),{name:"smoldot"})}();let a=null,n=[],r=new Map,o=new WeakMap;const h={name:null};let c=null;const l=()=>{null!==c&&globalThis.clearTimeout(c),c=globalThis.setTimeout((()=>{c=null,console.warn("Smoldot appears unresponsive"+(h.name?" while executing task `"+h.name+"`":"")+". Please open an issue at https://github.com/paritytech/smoldot/issues. If you have a debugger available, please pause execution, generate a stack trace of the thread that isn't the main execution thread, and paste it in the issue. Please also include any other log found in the console or elsewhere.")}),1e4)};return globalThis.setTimeout((()=>l()),15e3),function(e,t){e.onmessage=e=>t(e.data)}(i,(e=>{switch(e.kind){case"jsonrpc":{const t=r.get(e.chainId)?.jsonRpcCallback;t&&t(e.data);break}case"chainAddedOk":{const t=n.shift(),s=e.chainId;if(r.has(s))throw"Unexpected reuse of a chain ID";r.set(s,{jsonRpcCallback:t.jsonRpcCallback,databasePromises:new Array});const h={sendJsonRpc:e=>{if(a)throw a;if(!r.has(s))throw new v;if(!r.get(s)?.jsonRpcCallback)throw new C;e.length>=8388608||T(i,{ty:"request",request:e,chainId:s})},databaseContent:e=>{if(a)return Promise.reject(a);const t=r.get(s)?.databasePromises;if(!t)return Promise.reject(new v);const n=new Promise(((e,s)=>{t.push({resolve:e,reject:s})})),o=e||4294967295;return T(i,{ty:"databaseContent",chainId:s,maxUtf8BytesSize:o>=4*(1<<30)?4294967295:o}),n},remove:()=>{if(a)throw a;if(!r.delete(s))throw new v;console.assert(o.has(h)),o.delete(h),T(i,{ty:"removeChain",chainId:s})}};o.set(h,s),t.resolve(h);break}case"chainAddedErr":n.shift().reject(e.error);break;case"databaseContent":{const t=r.get(e.chainId)?.databasePromises;t&&t.shift().resolve(e.data);break}case"log":t(e.level,e.target,e.message);break;case"livenessPing":l();break;case"currentTask":h.name=e.taskName;break;default:return e}})),function(e,t){e.onerror=e=>{for(var t of(console.error("Smoldot has panicked"+(h.name?" while executing task `"+h.name+"`":"")+". This is a bug in smoldot. Please open an issue at https://github.com/paritytech/smoldot/issues with the following message:"),console.error(e),a=new E(e.toString()),n))"chainAdded"==t.ty&&t.reject(a);n=[];for(const e of r)for(const t of e[1].databasePromises)t.reject(a);r.clear()}}(i),T(i,{maxLogLevel:e.maxLogLevel||3,enableCurrentTask:!0,forbidTcp:e.forbidTcp||!1,forbidWs:e.forbidWs||!1,forbidNonLocalWs:e.forbidNonLocalWs||!1,forbidWss:e.forbidWss||!1}),{addChain:e=>{if(a)throw a;let t,s,r=[];if(e.potentialRelayChains)for(const t of e.potentialRelayChains){const e=o.get(t);void 0!==e&&r.push(e)}const h=new Promise(((e,i)=>{t=e,s=i}));return n.push({ty:"chainAdded",reject:s,resolve:t,jsonRpcCallback:e.jsonRpcCallback}),T(i,{ty:"addChain",chainSpec:e.chainSpec,databaseContent:"string"==typeof e.databaseContent?e.databaseContent:"",potentialRelayChains:r,jsonRpcRunning:!!e.jsonRpcCallback}),h},terminate:()=>a?Promise.reject(a):(a=new v,null!==c&&globalThis.clearTimeout(c),function(e){return e.terminate(),Promise.resolve()}(i))}}function T(e,t){e.postMessage(t)}var S,P,j,M,R,N,J,I,x,O,_,H,$,L,A,D,U,z=s(64146),F=s(91827),q=function(e,t,s,i,a){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!a)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!a:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?a.call(e,s):a?a.value=s:t.set(e,s),s},Z=function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)};const B=(0,u.k)("smoldot-provider"),G={chain_finalisedHead:"chain_finalizedHead",chain_subscribeFinalisedHeads:"chain_subscribeFinalizedHeads",chain_unsubscribeFinalisedHeads:"chain_unsubscribeFinalizedHeads"};class K{constructor(e,t,s){S.set(this,void 0),P.set(this,new f.K),j.set(this,new w),M.set(this,{}),R.set(this,{}),N.set(this,{}),J.set(this,void 0),I.set(this,!1),x.set(this,void 0),O.set(this,void 0),_.set(this,void 0),H.set(this,void 0),this.healthPingerInterval=2e3,$.set(this,(e=>{B.debug((()=>["received",e]));const t=JSON.parse(e);return(0,F.o)(t.method)?Z(this,L,"f").call(this,t):Z(this,A,"f").call(this,t)})),L.set(this,(e=>{const t=Z(this,M,"f")[e.id];if(t){try{const{method:s,subscription:i}=t,a=Z(this,P,"f").decodeResponse(e);if(t.callback(null,a),i){const e=`${i.type}::${a}`;Z(this,R,"f")[e]={...i,method:s},Z(this,N,"f")[e]&&Z(this,A,"f").call(this,Z(this,N,"f")[e])}}catch(e){t.callback(e,void 0)}delete Z(this,M,"f")[e.id]}else B.debug((()=>`Unable to find handler for id=${e.id}`))})),A.set(this,(e=>{const t=`${G[e.method]||e.method||"invalid"}::${e.params.subscription}`,s=Z(this,R,"f")[t];if(!s)return Z(this,N,"f")[t]=e,void B.debug((()=>`Unable to find handler for subscription=${t} responseId=${e.id}`));delete Z(this,N,"f")[t];try{const t=Z(this,P,"f").decodeResponse(e);s.callback(null,t)}catch(e){s.callback(e,void 0)}})),D.set(this,(e=>{if(0==e.shouldHavePeers)return Z(this,I,"f")?void 0:(q(this,I,!0,"f"),this.emit("connected"),void B.debug("emitted CONNECTED"));const t=e.peers,s=(t>0||!e.shouldHavePeers)&&!e.isSyncing;return B.debug("Simulating lifecylce events from system_health"),B.debug(`isConnected: ${Z(this,I,"f").toString()}, new peerCount: ${t}`),Z(this,I,"f")&&s?void 0:Z(this,I,"f")&&0===t?(q(this,I,!1,"f"),this.emit("disconnected"),void B.debug("emitted DISCONNECTED")):!Z(this,I,"f")&&s?(q(this,I,!0,"f"),this.emit("connected"),void B.debug("emitted CONNECTED")):void 0})),U.set(this,(()=>{this.send("system_health",[]).then(Z(this,D,"f")).catch((e=>this.emit("error",new z.Z(e))))})),this.connect=async()=>{(0,p.hu)(!Z(this,x,"f")&&!Z(this,I,"f"),"Client is already connected");try{if(q(this,x,Z(this,H,"f").start({forbidNonLocalWs:!0,maxLogLevel:3}),"f"),Z(this,_,"f")){const e=await Z(this,x,"f").addChain({chainSpec:Z(this,S,"f")});q(this,O,await Z(this,x,"f").addChain({chainSpec:Z(this,_,"f"),jsonRpcCallback:e=>{Z(this,$,"f").call(this,e)},potentialRelayChains:[e]}),"f")}else q(this,O,await Z(this,x,"f").addChain({chainSpec:Z(this,S,"f"),jsonRpcCallback:e=>{Z(this,$,"f").call(this,e)}}),"f");q(this,J,setInterval(Z(this,U,"f"),this.healthPingerInterval),"f")}catch(e){this.emit("error",e)}},q(this,S,e,"f"),q(this,H,s||i,"f"),q(this,J,null,"f"),t&&q(this,_,t,"f")}get hasSubscriptions(){return!0}clone(){throw new Error("clone() is not supported.")}async disconnect(){try{Z(this,x,"f")&&await Z(this,x,"f").terminate()}catch(e){this.emit("error",e)}finally{null!==Z(this,J,"f")&&clearInterval(Z(this,J,"f")),q(this,I,!1,"f"),this.emit("disconnected")}}get isConnected(){return Z(this,I,"f")}on(e,t){return Z(this,j,"f").on(e,t),()=>{Z(this,j,"f").removeListener(e,t)}}async send(e,t,s,i){return new Promise(((s,a)=>{(0,p.hu)(Z(this,x,"f"),"Client is not initialised"),(0,p.hu)(Z(this,O,"f"),"Chain is not initialised");const n=Z(this,P,"f").encodeJson(e,t),r=Z(this,P,"f").getId();B.debug((()=>["calling",e,n])),Z(this,M,"f")[r]={callback:(e,t)=>{e?a(e):s(t)},method:e,subscription:i},Z(this,O,"f").sendJsonRpc(n)}))}async subscribe(e,t,s,i){return await this.send(t,s,!1,{callback:i,type:e})}async unsubscribe(e,t,s){const i=`${e}::${s}`;return(0,F.o)(Z(this,R,"f")[i])?(B.debug((()=>`Unable to find active subscription=${i}`)),!1):(delete Z(this,R,"f")[i],await this.send(t,[s]))}emit(e,...t){Z(this,j,"f").emit(e,...t)}}S=new WeakMap,P=new WeakMap,j=new WeakMap,M=new WeakMap,R=new WeakMap,N=new WeakMap,J=new WeakMap,I=new WeakMap,x=new WeakMap,O=new WeakMap,_=new WeakMap,H=new WeakMap,$=new WeakMap,L=new WeakMap,A=new WeakMap,D=new WeakMap,U=new WeakMap},64146:(e,t,s)=>{s.d(t,{Z:()=>a});var i;class a extends Error{constructor(e,t="Got error response asking for system health"){super(t),i.set(this,void 0),function(e,t,s,i,a){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!a)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!a:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");"a"===i?a.call(e,s):a?a.value=s:t.set(e,s)}(this,i,e,"f"),Object.setPrototypeOf(this,new.target.prototype)}getCause(){return function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)}(this,i,"f")}}i=new WeakMap},91827:(e,t,s)=>{s.d(t,{f:()=>a,o:()=>i});const i=e=>void 0===e;function a(e,t){Object.keys(e).forEach((s=>{t&&t(e[s]),delete e[s]}))}}}]);